writeln(s) ::= <<println!("{}", <s> );>>
write(s) ::= <<print!("{}", <s> );>>
writeList(s) ::= << std::cout \<\< <s; separator=" \<\< "> \<\< std::endl;>>

False() ::= "false"
True() ::= "true"
Not(v) ::= "!<v>"
Assert(s) ::= ""
Cast(t,v) ::= "cast::\<_,<t>>(&*<v>)"
Append(a,b) ::= "<a>.to_string() + &(<b>).to_string()"
AppendStr(a,b) ::= <%<a>.to_string() + &(<b>)%>
Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "let mut <s> = <v>"

AssertIsList(v) ::= "" //not sure if possible in Rust
AssignLocal(s,v) ::= "<s> = <v>;"

InitIntMember(n,v) ::= <<
@parser::fields {<n>: isize,}
@parser::init   {<n>: <v>,}
>>
InitBooleanMember(n,v) ::= <<
@parser::fields {<n>: bool,}
@parser::init   {<n>: <v>,}
>>

IntArg(v) ::= "<v>: isize"
VarRef(v) ::= "<v>"

GetMember(n) ::= "recog.<n>"
SetMember(n,v) ::= "recog.<n> = <v>;"
AddMember(n,v) ::= "recog.<n> += <v>;"
PlusMember(n,v) ::= "recog.<n> + <v>"
MemberEquals(n,v) ::= "recog.<n> == <v>"
ModMemberEquals(n,m,v) ::= "recog.<n> % <m> == <v>"
ModMemberNotEquals(n,m,v) ::= "recog.<n> % <m> != <v>"

DumpDFA() ::= "recog.dump_dfa();"
Pass() ::= "/* do nothing */"

StringList() ::= "Vec\<String>"
BuildParseTrees() ::= "recog.build_parse_trees = true;"
BailErrorStrategy() ::= "recog.err_handler = Box::new(antlr_rust::error_strategy::BailErrorStrategy::new());"

ToStringTree(s) ::= "<s>.to_string_tree(&recog.base)"
Column() ::= "recog.get_char_position_in_line()"
Text() ::= "recog.get_text()"
ValEquals(a,b) ::= "<a> == <b>"
TextEquals(a) ::= "recog.get_text() == \"<a>\""
PlusText(a) ::="\"<a>\".to_owned() + &recog.get_text()"
InputText() ::= "recog.base.input.get_all_text()"
LTEquals(i, v) ::= "recog.input.lt(<i>).unwrap().get_text() == <v>"
LANotEquals(i, v) ::= "recog.input.la(<i>) != <v>"
TokenStartColumnEquals(i) ::= "recog.token_start_column == <i>"

ImportListener(X) ::= ""

GetExpectedTokenNames() ::= "recog.base.get_expected_tokens().to_token_string(recog.get_vocabulary())"

RuleInvocationStack() ::= "format!(\"[{}]\",recog.get_rule_invocation_stack().join(\", \"))"

LL_EXACT_AMBIG_DETECTION() ::= <<recog.get_interpreter().set_prediction_mode(antlr_rust::prediction_mode::PredictionMode::LL_EXACT_AMBIG_DETECTION);>>

//ParserToken(parser, token) ::= <%<parser>.<token>%>
ParserToken(parser, token) ::= <%self::<token>%>

Production(p) ::= <%<p>%>

Result(r) ::= <%<r>%>

ParserPropertyMember() ::= <<
@members {
fn Property(&self) -> bool {
	return true;
}
}
>>

ParserPropertyCall(p, call) ::= "recog.<call>"

PositionAdjustingLexer() ::= <<
protected:
  class PositionAdjustingLexerATNSimulator : public antlr4::atn::LexerATNSimulator {
  public:
    PositionAdjustingLexerATNSimulator(antlr4::Lexer *recog, const antlr4::atn::ATN &atn, std::vector\<antlr4::dfa::DFA> &decisionToDFA,
                                       antlr4::atn::PredictionContextCache &sharedContextCache)
      : antlr4::atn::LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
    }

    void resetAcceptPosition(antlr4::CharStream *input, int index, int line, int charPositionInLine) {
      input->seek(index);
      _line = line;
      _charPositionInLine = charPositionInLine;
      consume(input);
    }

  };

public:
  virtual std::unique_ptr\<antlr4::Token> nextToken() override {
    if (dynamic_cast\<PositionAdjustingLexerATNSimulator *>(_interpreter) == nullptr) {
      delete _interpreter;
      _interpreter = new PositionAdjustingLexerATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
    }

    return antlr4::Lexer::nextToken();
  }

  virtual antlr4::Token* emit() override {
    switch (type) {
      case TOKENS:
        handleAcceptPositionForKeyword("tokens");
        break;

      case LABEL:
        handleAcceptPositionForIdentifier();
        break;

      default:
        break;
    }
    return antlr4::Lexer::emit();
  }

private:
  bool handleAcceptPositionForIdentifier() {
    std::string tokenText = getText();
    int identifierLength = 0;
    while (identifierLength \< tokenText.length() && isIdentifierChar(tokenText[identifierLength])) {
      identifierLength++;
    }

    if (getInputStream()->index() > tokenStartCharIndex + identifierLength) {
      int offset = identifierLength - 1;
      getInterpreter\<PositionAdjustingLexerATNSimulator>()->resetAcceptPosition(getInputStream(),
        tokenStartCharIndex + offset, tokenStartLine, tokenStartCharPositionInLine + offset);
      return true;
    }

    return false;
  }

  bool handleAcceptPositionForKeyword(const std::string &keyword) {
    if (getInputStream()->index() > tokenStartCharIndex + keyword.length()) {
      long offset = keyword.size() - 1;
      getInterpreter\<PositionAdjustingLexerATNSimulator>()->resetAcceptPosition(getInputStream(),
        tokenStartCharIndex + offset, tokenStartLine, tokenStartCharPositionInLine + offset);
      return true;
    }

    return false;
  }

  static bool isIdentifierChar(char c) {
    return std::isalnum(c) || c == '_';
  }

public:
>>

BasicListener(X) ::= <<
@parser::definitions {
use antlr_rust::tree::ParseTreeListener;
struct TestListener;

impl ParseTreeListener for TestListener{
	fn visit_terminal(&self, node: &TerminalNode) {
		println!("{}",node.symbol.get_text());
	}
}
impl TListener for TestListener{}
}
>>

WalkListener(s) ::= <<
let walker = antlr_rust::tree::ParseTreeWalker;
let mut listener:Box\<dyn TListener> = Box::new(TestListener);
walker.walk(&mut listener, <s>.deref());
>>

TreeNodeWithAltNumField(X) ::= <<
@parser::members {
class MyRuleNode : public antlr4::ParserRuleContext {
public:
  size_t altNum;
	MyRuleNode(antlr4::ParserRuleContext *parent, int invokingStateNumber)
		: antlr4::ParserRuleContext(parent, invokingStateNumber) {
	}
	virtual size_t getAltNumber() const override { return altNum; }
	virtual void setAltNumber(size_t altNum) override { this->altNum = altNum; }
};
}
>>

TokenGetterListener(X) ::= <<
@parser::definitions {
use antlr_rust::tree::ParseTreeListener;
use crate::antlr_rust::tree::Tree;
struct TestListener;

impl TListener for TestListener{
	fn exit_a(&mut self, node: &AContext) {
		if node.get_children().len() == 2 {
			println!("{} {} {:?}",node.INT(0).symbol.get_text(),node.INT(1).symbol.get_text(),node.INT_all())
		} else{
			println!("{}",node.ID().symbol);
		}
	}
}
impl ParseTreeListener for TestListener{}
}
>>

RuleGetterListener(X) ::= <<
@parser::definitions {

use antlr_rust::tree::ParseTreeListener;
use crate::antlr_rust::tree::Tree;
struct TestListener;

impl TListener for TestListener{
	fn exit_a(&mut self, node: &AContext) {
		if node.get_children().len() == 2 {
			println!("{} {} {}",
				node.b(0).get_start().as_ref().unwrap().get_text(),
				node.b(1).get_start().as_ref().unwrap().get_text(),
				node.b_all()[0].get_start().as_ref().unwrap().get_text(),
			)
		} else{
			println!("{}",node.b(0).get_start().as_ref().unwrap().get_text());
		}
	}
}
impl ParseTreeListener for TestListener{}
}
>>


LRListener(X) ::= <<
@parser::definitions {
use antlr_rust::tree::ParseTreeListener;
use antlr_rust::tree::Tree;
struct TestListener;

impl ParseTreeListener for TestListener{}
impl TListener for TestListener{
	fn exit_e(&mut self, ctx: &EContext) {
		if ctx.get_children().len() == 3 {
			println!("{} {} {}",ctx.e(0).get_start().unwrap().get_text(),ctx.e(1).get_start().unwrap().get_text(),ctx.e_all()[0].get_start().unwrap().get_text());
		} else {
			println!("{}",ctx.INT().symbol.get_text());
		}
	}
}
}
>>

LRWithLabelsListener(X) ::= <<
@parser::definitions {

use antlr_rust::tree::ParseTreeListener;
use antlr_rust::tree::Tree;
struct TestListener;

impl ParseTreeListener for TestListener{}
impl TListener for TestListener{
	fn exit_Call(&mut self, ctx: &CallContext) {
		println!("{} {:?}",ctx.e().get_start().unwrap().get_text(),ctx.eList().to_string(None,None));
	}
	fn exit_Int(&mut self, ctx: &IntContext){
		println!("{}",ctx.INT().symbol.get_text());
	}
}
}
>>

DeclareContextListGettersFunction() ::= <<
void foo() {
  SContext *s;
  std::vector\<AContext *> a = s->a();
  std::vector\<BContext *> b = s->b();
}
>>

Declare_foo() ::= <<pub fn foo(&self) {
	println!("foo");
}
>>

Invoke_foo() ::= "recog.foo();"

Declare_pred() ::= <<
pub fn pred(&self,v:bool)-> bool {
	println!("eval={}",v);
	return v;
}
>>

Invoke_pred(v) ::= <<recog.pred(<v>)>>

ContextRuleFunction(ctx, rule) ::= "<ctx>.<rule>.as_ref().unwrap()"
StringType() ::= "String"
ContextMember(ctx, subctx, member) ::= "<ctx>.<subctx>.get_<member>()"
