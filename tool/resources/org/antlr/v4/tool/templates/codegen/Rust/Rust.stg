
/*
 * [The "BSD license"]
 *  Copyright (c) 2012-2016 Terence Parr
 *  Copyright (c) 2012-2016 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than a primitive type is an object
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, namedActions, contextSuperClass) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
mod <file.genPackage>{
<endif>
<namedActions.header>
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![feature(try_blocks)]
use antlr_rust::prediction_context::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::token_source::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::{ANTLRError, NoViableAltError};
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::Recognizer;
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext};
use antlr_rust::tree::TerminalNode;
use antlr_rust::token::TOKEN_EOF;
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
<if(file.genListener)>
use super::<file.grammarName; format="low">listener::*;
<endif>

use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};

<parser>
<if(file.genPackage)>
}
<endif>
>>

ListenerFile(file, header, namedActions) ::= <<
#![allow(non_snake_case)]
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<header>
use antlr_rust::tree::ParseTreeListener;
use antlr_rust::parser_rule_context::ParserRuleContext;
use antlr_rust::parser::ListenerCaller;
use super::<file.grammarName; format="low">parser::*;

pub trait <file.grammarName>Listener : ParseTreeListener{

<file.listenerNames:{lname |

/**
<if(file.listenerLabelRuleNames.(lname))>
 * Enter a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
<else>
 * Enter a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * @param ctx the parse tree
 */
fn enter_<lname>(&mut self, ctx: &<lname; format="cap">Context) { \}
/**
<if(file.listenerLabelRuleNames.(lname))>
 * Exit a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
<else>
 * Exit a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * @param ctx the parse tree
 */
fn exit_<lname>(&mut self, ctx: &<lname; format="cap">Context) { \}}; separator="\n">
}

pub struct <file.grammarName>ListenerCaller;

impl ListenerCaller\<dyn <file.grammarName>Listener> for <file.grammarName>ListenerCaller{
	fn enter_rule(ctx: &dyn ParserRuleContext, listener: &mut dyn <file.grammarName>Listener) {
    	listener.enter_every_rule(ctx);
		match ctx.get_rule_index(){
			<file.listenerNames:{lname |
	RULE_<lname> => listener.enter_<lname>(unsafe{&*(ctx as *const dyn ParserRuleContext as *const <lname; format="cap">Context)\}),
			};separator="\n">
			_ => panic!("invalid rule")
		}
	}

	fn exit_rule(ctx: &dyn ParserRuleContext, listener: &mut dyn <file.grammarName>Listener) {
       	listener.exit_every_rule(ctx);
        match ctx.get_rule_index(){
        	<file.listenerNames:{lname |
    RULE_<lname> => listener.exit_<lname>(unsafe{&*(ctx as *const dyn ParserRuleContext as *const <lname; format="cap">Context)\}),
        	};separator="\n">
        	_ => panic!("invalid rule")
        }
	}
}

>>

BaseListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
mod <file.genPackage>{
<endif>
<header>
<! blank base class is useless in Rust!>
<if(file.genPackage)>
}
<endif>
>>

VisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
package <file.genPackage>;
<endif>
<header>
use antlr_runtime::tree::ParseTreeVisitor;

/**
 * This interface defines a complete generic visitor for a parse tree produced
 * by {@link <file.parserName>}.
 *
 * @param \<T> The return type of the visit operation. Use {@link Void} for
 * operations with no return type.
 */
pub trait  <file.grammarName>Visitor\<T>: ParseTreeVisitor\<T> {
	<file.visitorNames:{lname |
/**
<if(file.visitorLabelRuleNames.(lname))>
 * Visit a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.visitorLabelRuleNames.(lname)>\}.
<else>
 * Visit a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * @param ctx the parse tree
 * @return the visitor result
 */
fn visit<lname; format="cap">(ctx: <file.parserName>.<lname; format="cap">Context) -> T;}; separator="\n">
}
>>

BaseVisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
package <file.genPackage>;
<endif>
<header>
use antlr_runtime::tree::AbstractParseTreeVisitor;

/**
 * This class provides an empty implementation of {@link <file.grammarName>Visitor},
 * which can be extended to create a visitor which only needs to handle a subset
 * of the available methods.
 *
 * @param \<T> The return type of the visit operation. Use {@link Void} for
 * operations with no return type.
 */
struct <file.grammarName>BaseVisitor\<T>:<file.grammarName>Visitor\<T> {
	base : AbstractParseTreeVisitor\<T>
	}

impl\<T> <file.grammarName>Visitor\<T> for <file.grammarName>BaseVisitor\<T> {
	<file.visitorNames:{lname |
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation returns the result of calling
 * {@link #visitChildren\} on {@code ctx\}.\</p>
 */
pub fn visit<lname; format="cap">(ctx: <file.parserName>.<lname; format="cap">Context) -> T { base.visitChildren(ctx) \}}; separator="\n">
}
>>

fileHeader(grammarFileName, ANTLRVersion) ::= <<
// Generated from <grammarFileName; format="java-escape"> by ANTLR <ANTLRVersion>
>>

Parser(parser, funcs, atn, sempredFuncs, superClass) ::= <<
<Parser_(ctor="parser_ctor", ...)>
>>

Parser_(parser, funcs, atn, sempredFuncs, ctor, superClass) ::= <<
<!@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})!>
<! TODO: static { RuntimeMetaData.checkVersion("<file.ANTLRVersion>", RuntimeMetaData.VERSION); }!>

	<if(parser.tokens)>
		<parser.tokens:{k | pub const <k>:isize=<parser.tokens.(k)>;}; separator=" \n">
	<endif>
	<parser.rules:{r | pub const RULE_<r.name>:usize = <r.index>;}; separator=" \n">
	pub const ruleNames: [&'static str; <length(parser.ruleNames)>] =  [
		<parser.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
	];

	<vocabulary(parser.literalNames, parser.symbolicNames)>

pub struct <parser.name> {
<if(parser.file.genListener)>
	base:BaseParser\<<parser.name>Ext, dyn <parser.grammarName>Listener, <parser.grammarName>ListenerCaller>,
<else>
    base:<superClass; null="BaseParser">,
<endif>
	interpreter:Arc\<ParserATNSimulator>,
	_shared_context_cache: Box\<PredictionContextCache>,
    err_handler: Box\<dyn ErrorStrategy>,

}

impl <parser.name> {

	pub fn get_serialized_atn() -> &'static str { unimplemented!() }

    pub fn set_error_strategy(&mut self, strategy: Box\<dyn ErrorStrategy>) {
        self.err_handler = strategy
    }

	<namedActions.members>

    pub fn new(input: Box\<dyn TokenStream>) -> Self {
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				<parser.name>Ext
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: Box::new(DefaultErrorStrategy::new()),
        }
    }
}

impl Deref for <parser.name>{
    type Target = BaseParser\<<parser.name>Ext, dyn <parser.grammarName>Listener, <parser.grammarName>ListenerCaller>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl DerefMut for <parser.name>{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct <parser.name>Ext;

impl Recognizer for <parser.name>Ext{
	fn get_grammar_file_name(&self) -> & str{ "<parser.grammarFileName>"}

	fn get_rule_names(&self) -> &[& str] {&ruleNames}

	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }



<if(sempredFuncs)>
	fn sempred(&mut self,lexer:&mut BaseLexer,_localctx: Option\<&dyn ParserRuleContext>, rule_index: usize, pred_index: usize)->bool{
		match rule_index {
		<parser.sempredFuncs.values:{f|
			<f.ruleIndex> => self.<f.name>_sempred(lexer,_localctx, pred_index),}; separator="\n">
			_ => true
		}
	}
}
impl <parser.name>Ext{
	<sempredFuncs.values; separator="\n">
<endif>

}
<funcs; separator="\n">
<atn>

>>

vocabulary(literalNames, symbolicNames) ::= <<

pub const _LITERAL_NAMES: [Option\<&'static str>;<length(literalNames)>] = [
	<literalNames:{t | Some(<t>)}; null="None", separator=", ", wrap, anchor>
];
pub const _SYMBOLIC_NAMES: [Option\<&'static str>;<length(symbolicNames)>]  = [
	<symbolicNames:{t | Some(<t>)}; null="None", separator=", ", wrap, anchor>
];
lazy_static!{
    static ref _shared_context_cache: Arc\<PredictionContextCache> = Arc::new(PredictionContextCache::new());
	static ref VOCABULARY: Box\<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
}
>>

dumpActions(recog, argFuncs, actionFuncs, sempredFuncs) ::= <<
	<if(actionFuncs)>

	fn action(&mut self,_localctx: Option\<&dyn ParserRuleContext>, rule_index: isize, action_index: isize,
	          lexer:&mut BaseLexer
	    ){
	    	match rule_index {
			<recog.actionFuncs.values:{f|
	        <f.ruleIndex> =>
	        	self.<f.name>_action(_localctx, action_index, lexer), }; separator="\n">
			_ => {}
		}
	}
	<endif>
	<if(sempredFuncs)>
	fn sempred(&mut self,_localctx: Option\<&dyn ParserRuleContext>, rule_index: isize, pred_index: isize,
	           lexer:&mut BaseLexer
	    ) -> bool {
	    	match rule_index {
			<recog.sempredFuncs.values:{f|
	        <f.ruleIndex> =>
	        	self.<f.name>_sempred(_localctx, pred_index, lexer), }; separator="\n">
			_ => true
		}
	}

	<endif>
}

impl <recog.name>Actions{
<if(actionFuncs)>
	<actionFuncs.values; separator="\n">
<endif>
<if(sempredFuncs)>
	<sempredFuncs.values; separator="\n">
<endif>


>>

parser_ctor(p) ::= <<
>>

/* This generates a private method since the actionIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleActionFunction(r, actions) ::= <<

fn <r.name>_action(&mut self,_localctx: Option\<&dyn ParserRuleContext>, action_index: isize,
				   lexer:&mut BaseLexer
	) {
	match action_index {
	<actions:{index|
 		<index>=>{
			<actions.(index)>
		\},
	}; separator="\n">
		_ => {}
	}
}
>>

/* This generates a private method since the predIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleSempredFunction(r, actions) ::= <<


fn <r.name>_sempred(&mut self,_localctx: Option\<&dyn ParserRuleContext>, pred_index:isize,
					lexer:&mut BaseLexer
	) -> bool {
	match pred_index {
	<actions:{index|
		<index>=>{
			<actions.(index)>
		\}}; separator="\n">
		_ => true
	}
}
>>

RuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,namedActions,finallyAction,postamble,exceptions) ::= <<

<ruleCtx>
<!<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">!>

<!pub trait <currentRule.name> {
	<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>fn <endif> <currentRule.name>(&mut self<args; separator=",">) ->Result\<()/*<currentRule.ctxType>*/,ANTLRError>;
}!>

impl <parser.name>{
	<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>pub fn<endif> <currentRule.name>(&mut self,<args; separator=",">) ->Result\<()/*<currentRule.ctxType>*/,ANTLRError> {
		<!keeping parent ctx here because otherwise if we are not building tree parent would be referenced only by Weak reference from current ctx !>
		let _parentctx = self.ctx.take();
		let mut _localctx = <currentRule.ctxType>::new(_parentctx.clone(), self.base.get_state()<currentRule.args:{a | , <a.name>}>);
		//let mut _localctx = BaseRuleContext::new(self.ctx.take(), self.base.get_state());
        //self.ctx = Some(_localctx);
        //let mut _localctx = self.ctx.as_deref_mut().unwrap();
        self.base.enter_rule(_localctx, <currentRule.startState>, RULE_<currentRule.name>);
		<namedActions.init>
		<locals; separator="\n">
		let result: Result\<(), ANTLRError> = try {

	<if(currentRule.hasLookaheadBlock)>
			let mut _alt: isize;
	<endif>
			<code>
			<postamble; separator="\n">
			<namedActions.after>
		};
		<if(exceptions)>
		<exceptions; separator="\n">
		<else>
		match result {
		Ok(_)=>{},
		Err(ref re) => {
				//_localctx.exception = re;
				self.err_handler.report_error(&mut self.base, re);
				self.err_handler.recover(&mut self.base, re);
			}
		}
		<endif>
		<finallyAction>
		self.base.exit_rule();

		Ok(())
	}
}
>>

LeftRecursiveRuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,
	namedActions,finallyAction,postamble) ::=
<<

<ruleCtx>
<!<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">!>
impl <parser.name>{

	<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>pub fn <endif> <currentRule.name>(&mut self,<args; separator=", ">) -> Result\<<currentRule.ctxType>, ANTLRError> {
		self.<currentRule.name>_rec(0<currentRule.args:{a | , <a.name>}>)
	}

	fn <currentRule.name>_rec(&mut self, _p: isize<args:{a | , <a>}>) -> Result\<<currentRule.ctxType>, ANTLRError> {
		let _parentctx = self.ctx.take();
		//let _parentState = self.base.get_state();
		let mut _localctx = <currentRule.ctxType>::new(_parentctx.clone(), self.base.get_state()<currentRule.args:{a | , <a.name>}>);
        //self.ctx = Some(_localctx);
	    //let mut _localctx = self.ctx.as_deref_mut().unwrap();
		//let _prevctx = _localctx;
		let _startState = <currentRule.startState>;
		self.base.enter_recursion_rule(_localctx, <currentRule.startState>, RULE_<currentRule.name>, _p);
		<namedActions.init>
		<locals; separator="\n">
		let result: Result\<(), ANTLRError> = try {
	<if(currentRule.hasLookaheadBlock)>
			let mut _alt: isize;
	<endif>
			<code>
			<postamble; separator="\n">
			<namedActions.after>
		};
		match result {
		Ok(_) => {},
		Err(ref re)=>{
			//_localctx.exception = re;
			self.err_handler.report_error(&mut self.base, re);
	        self.err_handler.recover(&mut self.base, re);}
		}
		<finallyAction>
		self.base.unroll_recursion_context(_parentctx);

		Ok(())
	}
}
>>

CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if(currentOuterMostAltCodeBlock.altLabel)>let _localctx = <currentOuterMostAltCodeBlock.altLabel; format="cap">Context::new(_localctx);
self.base.enter_outer_alt(_localctx, <currentOuterMostAltCodeBlock.alt.altNum>);
<else>
self.base.enter_outer_alt(None, <currentOuterMostAltCodeBlock.alt.altNum>);
<endif>
<CodeBlockForAlt(currentAltCodeBlock=currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
{
<locals; separator="\n">
<preamble; separator="\n">
<ops; separator="\n">
}
>>

LL1AltBlock(choice, preamble, alts, error) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
<if(choice.label)><labelref(choice.label)> = self.base.input.lt(1);<endif>
<preamble; separator="\n">
match self.base.input.la(1) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	=> {
		<alt>
	\}
	}; separator="\n">
	_ => Err(<error>)?
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
match self.base.input.la(1) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	=> {
    	<alt>
    \}
    }; separator="\n">
	_ => {}
}
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
<preamble; separator="\n">
if <expr> {
	<alts; separator="\n">
}
<!else if ( !(<followExpr>) ) <error>!>
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
<preamble; separator="\n">
while <loopExpr> {
	<alts; separator="\n">
	self.base.set_state(<choice.loopBackStateNumber>);
	self.err_handler.sync(&mut self.base)?;
	<iteration>
}
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
self.base.set_state(<choice.blockStartStateNumber>); <! alt block decision !>
self.err_handler.sync(&mut self.base)?;
<preamble; separator="\n">
loop {
	<alts; separator="\n">
	self.base.set_state(<choice.stateNumber>); <! loopback/exit decision !>
	self.err_handler.sync(&mut self.base)?;
	<iteration>
	if !(<loopExpr>) {break}
}
>>

// LL(*) stuff

AltBlock(choice, preamble, alts, error) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
<if(choice.label)><labelref(choice.label)> = self.base.input.lt(1);<endif>
<preamble; separator="\n">
match  self.interpreter.adaptive_predict(<choice.decision>,&mut self.base)? {
<alts:{alt |
	<i> =>{
		<alt>
	\}
	}; separator=",\n">
	_ => {}
}
>>

OptionalBlock(choice, alts, error) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
match  self.interpreter.adaptive_predict(<choice.decision>,&mut self.base)? {
<alts:{alt |
	x if x == <i><if(!choice.ast.greedy)>+1<endif>=>{
		<alt>
	\}
	}; separator="\n">
	_ => {}
}
>>

StarBlock(choice, alts, sync, iteration) ::= <<
self.base.set_state(<choice.stateNumber>);
self.err_handler.sync(&mut self.base)?;
_alt = self.interpreter.adaptive_predict(<choice.decision>,&mut self.base)?;
while { _alt!=<choice.exitAlt> && _alt!=INVALID_ALT } {
	if _alt==1<if(!choice.ast.greedy)>+1<endif> {
		<iteration>
		<alts> <! should only be one !>
	}
	self.base.set_state(<choice.loopBackStateNumber>);
	self.err_handler.sync(&mut self.base)?;
	_alt = self.interpreter.adaptive_predict(<choice.decision>,&mut self.base)?;
}
>>

PlusBlock(choice, alts, error) ::= <<
self.base.set_state(<choice.blockStartStateNumber>); <! alt block decision !>
self.err_handler.sync(&mut self.base)?;
_alt = 1<if(!choice.ast.greedy)>+1<endif>;
loop {
	match _alt {
	<alts:{alt|
    x if x == <i><if(!choice.ast.greedy)>+1<endif>=>
	<alt>
	}; separator=",\n">
	_ =>
		Err(<error>)?
	}
	self.base.set_state(<choice.loopBackStateNumber>); <! loopback/exit decision !>
	self.err_handler.sync(&mut self.base)?;
	_alt = self.interpreter.adaptive_predict(<choice.decision>,&mut self.base)?;
	if _alt!=<choice.exitAlt> && _alt!=INVALID_ALT {break}
}
>>

Sync(s) ::= "self.err_handler.sync(<s.expecting.name>)?;"

ThrowNoViableAlt(t) ::= "ANTLRError::NoAltError(NoViableAltError::new())"

TestSetInline(s) ::= <<
<s.bitsets:{bits | <if(rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount>) & !0x3f) == 0
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <%
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> && ((1usize \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes:{ttype | (1usize \<\< <offsetShift(ttype, bits.shift)>)}; separator=" | ">)) != 0)
%>

isZero ::= [
"0":true,
default:false
]

offsetShift(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>(<shiftAmount> - <offset>)<else><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
%>

cases(ttypes) ::= <<
<ttypes:{t |  <t> }; separator="|",wrap>
>>

InvokeRule(r, argExprsChunks) ::= <<
self.base.set_state(<r.stateNumber>);
<if(r.labels)><r.labels:{l | <labelref(l)> = }><endif>self.<r.name><if(r.ast.options.p)>_rec<endif>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>)?;
>>

MatchToken(m) ::= <<
self.base.set_state(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }><endif>self.base.match_token(<m.name>,self.err_handler.as_mut())?;
>>

MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
self.base.set_state(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }>self.base.input.lt(1);<endif>
<capture>
if { <if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>) } {
	<if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>self.err_handler.recover_inline(&mut self.base);
}
else {
	if  self.base.input.la(1)==TOKEN_EOF { self.base.matched_eof = true};
	self.err_handler.report_match(&mut self.base);
	self.base.consume();
}
>>

Wildcard(w) ::= <<
self.base.set_state(<w.stateNumber>);
<if(w.labels)><w.labels:{l | <labelref(l)> = }><endif>self.base.match_wildcard(self.err_handler.as_mut())?;
>>

// ACTION STUFF

Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "<chunks>"

SemPred(p, chunks, failChunks) ::= <<
self.base.set_state(<p.stateNumber>);
if !(<chunks>) {Err(FailedPredicateError::new(self, <p.predicate><if(failChunks)>, <failChunks><elseif(p.msg)>, <p.msg><endif>))?;}
>>

ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
	<catchAction>
}
>>

// lexer actions are not associated with model objects

LexerSkipCommand()  ::= "skip();"
LexerMoreCommand()  ::= "more();"
LexerPopModeCommand() ::= "pop_mode();"

LexerTypeCommand(arg, grammar)      ::= "_type = <arg>;"
LexerChannelCommand(arg, grammar)   ::= "_channel = <arg>;"
LexerModeCommand(arg, grammar)      ::= "_mode = <arg>;"
LexerPushModeCommand(arg, grammar)  ::= "push_mode(<arg>);"

ActionText(t) ::= "<t.text>"
ActionTemplate(t) ::= "<t.st>"
ArgRef(a) ::= "_localctx.<a.name>"
LocalRef(a) ::= "_localctx.<a.name>"
RetValueRef(a) ::= "_localctx.<a.name>"
QRetValueRef(a) ::= "<ctx(a)>.<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<ctx(t)>::<t.name>"
LabelRef(t) ::= "<ctx(t)>::<t.name>"
ListLabelRef(t) ::= "<ctx(t)>.<ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "<ctx(s)>.<s.name> = <rhsChunks>;"

TokenLabelType() ::= "<file.TokenLabelType; null={Token}>"
InputSymbolType() ::= "<file.InputSymbolType; null={Token}>"

TokenPropertyRef_text(t) ::= "<ternary_op(cond={<ctx(t)>.<t.label>!=null},a={<ctx(t)>.<t.label>.get_text()},b={null})>"
TokenPropertyRef_type(t) ::= "(<ctx(t)>.<t.label>!=null?<ctx(t)>.<t.label>.getType():0)"
TokenPropertyRef_line(t) ::= "(<ctx(t)>.<t.label>!=null?<ctx(t)>.<t.label>.getLine():0)"
TokenPropertyRef_pos(t) ::= "(<ctx(t)>.<t.label>!=null?<ctx(t)>.<t.label>.getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "(<ctx(t)>.<t.label>!=null?<ctx(t)>.<t.label>.getChannel():0)"
TokenPropertyRef_index(t) ::= "(<ctx(t)>.<t.label>!=null?<ctx(t)>.<t.label>.getTokenIndex():0)"
TokenPropertyRef_int(t) ::= "(<ctx(t)>.<t.label>!=null?Integer.valueOf(<ctx(t)>.<t.label>.get_text()):0)"

RulePropertyRef_start(r) ::= "(<ctx(r)>.<r.label>!=null?(<ctx(r)>.<r.label>.start):null)"
RulePropertyRef_stop(r)	 ::= "(<ctx(r)>.<r.label>!=null?(<ctx(r)>.<r.label>.stop):null)"
RulePropertyRef_text(r)	 ::= "(<ctx(r)>.<r.label>!=null?input.get_text(<ctx(r)>.<r.label>.start,<ctx(r)>.<r.label>.stop):null)"
RulePropertyRef_ctx(r)	 ::= "<ctx(r)>.<r.label>"
RulePropertyRef_parser(r)	 ::= "self.base"

ternary_op(cond,a,b) ::= " if cond {<a>} else {<b>}"

ThisRulePropertyRef_start(r) ::= "_localctx.get_start()"
ThisRulePropertyRef_stop(r)	 ::= "_localctx.get_stop()"
ThisRulePropertyRef_text(r)	 ::= "{let temp = self.base.input.index()-1; self.base.input.get_text_from_interval(self.get_parser_rule_context().get_start(), temp)}"
ThisRulePropertyRef_ctx(r)	 ::= "_localctx"
ThisRulePropertyRef_parser(r)	 ::= "self.base"

NonLocalAttrRef(s)		 ::= "((\<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name>"
SetNonLocalAttr(s, rhsChunks)	  ::=
	"((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name> = <rhsChunks>;"

AddToLabelList(a) ::= "<ctx(a.label)>.<a.listName>.add(<labelref(a.label)>);"

TokenDecl(t) ::= "let <t.name>: <TokenLabelType()>"
TokenTypeDecl(t) ::= "let mut <t.name>: isize;"
TokenListDecl(t) ::= "let <t.name>:Vec\<Token> = Vec::new();"
RuleContextDecl(r) ::= "let <r.name>: <r.ctxName>;"
RuleContextListDecl(rdecl) ::= "let <rdecl.name>:Vec\<<rdecl.ctxName>> = Vec::new();"

ContextTokenGetterDecl(t)      ::= <<
    pub fn <t.name>(&self) -> &TerminalNode {
    	unimplemented!()
    	//getToken(<parser.name>.<t.name>, 0)
    }>>
ContextTokenListGetterDecl(t)  ::=<<
    pub fn <t.name>s(&self) -> Vec\<&TerminalNode> {
    	unimplemented!()
    	//getTokens(<parser.name>.<t.name>)
    }>>
ContextTokenListIndexedGetterDecl(t)  ::= <<
pub fn <t.name>(&self, i: usize) -> &TerminalNode {
	unimplemented!()
	//getToken(<parser.name>.<t.name>, i)
}
>>
ContextRuleGetterDecl(r)       ::= <<
pub fn <r.name>(&self) -> &<r.ctxName> {
	unimplemented!()
	//getRuleContext(<r.ctxName>.class,0)
}
>>
ContextRuleListGetterDecl(r)   ::= <<
pub fn <r.name>s(&self) ->  Vec\<&<r.ctxName>\>{
	unimplemented!()
	//getRuleContexts(<r.ctxName>.class)
}
>>
ContextRuleListIndexedGetterDecl(r)   ::= <<
pub fn <r.name>(&self, i: usize) -> &<r.ctxName>{
	unimplemented!()
	//getRuleContext(<r.ctxName>.class,i);
}
>>

LexerRuleContext() ::= "RuleContext"

/** The rule context name is the rule followed by a suffix; e.g.,
 *	r becomes rContext.
 */
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= "<tokenName>"
ImplicitRuleLabel(ruleName)	  ::= "<ruleName>"
ImplicitSetLabel(id)		  ::= "_tset<id>"
ListLabelName(label)		  ::= "<label>"

CaptureNextToken(d) ::= "<d.varName> = self.base.input.lt(1);"
CaptureNextTokenType(d) ::= "<d.varName> = self.base.input.la(1);"

StructDecl(struct,ctorAttrs,attrs,getters,dispatchMethods,interfaces,extensionMembers)
	::= <<
pub struct <struct.name> <if(interfaces)>:<interfaces; separator="+ "><endif> {
	base:<if(contextSuperClass)><contextSuperClass><else>BaseParserRuleContext\<<struct.name>Ext><endif>,

}

impl Deref for <struct.name>{
    type Target = BaseParserRuleContext\<<struct.name>Ext>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl DerefMut for <struct.name>{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct <struct.name>Ext{<attrs:{a | public <a>;}; separator=",\n">}
impl CustomRuleContext for <struct.name>Ext{
	fn get_rule_index(&self) -> usize {
		RULE_<struct.derivedFromName>
	}
}


impl <struct.name>{

	<getters:{g | <g>}; separator="\n">
	<if(ctorAttrs)>pub fn new(parent: ParserRuleContext, invokingState:usize) { Self {base:super(parent, invokingState);} }<endif>
	pub fn new(parent: Option\<Rc\<dyn ParserRuleContext\>>, invoking_state: isize<ctorAttrs:{a | , <a>}>) -> Rc\<dyn ParserRuleContext> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,<struct.name>Ext{<struct.ctorAttrs:{a | <a.name> : <a.name>}; separator=",\n">}),
		)
	}
<if(struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
	//public <struct.name>() { }
	pub fn copyFrom(& mut self, ctx: <struct.name>) {
		self.base.copyFrom(ctx);
		<struct.attrs:{a | self.<a.name> = ctx.<a.name>;}; separator="\n">
	}
<endif>
	<!<dispatchMethods; separator="\n">!>
	<extensionMembers; separator="\n">
}
>>

AltLabelStructDecl(struct,attrs,getters,dispatchMethods) ::= <<
pub struct <struct.name>  {
    base : <currentRule.name; format="cap">Context,
	<attrs:{a | pub <a>,}; separator="\n">
}
impl <struct.name>{
	<getters:{g | <g>}; separator="\n">
	pub fn <struct.name>(ctx: <currentRule.name; format="cap">Context) { copyFrom(ctx); }
	<dispatchMethods; separator="\n">
}
>>

ListenerDispatchMethod(method) ::= <<
pub fn <if(method.isEnter)>enter<else>exit<endif>Rule(listener: ParseTreeListener) {
	if { listener instanceof <parser.grammarName>Listener } ((<parser.grammarName>Listener)listener).<if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">(this);
}
>>

VisitorDispatchMethod(method) ::= <<
pub fn \<T> accept(visitor: ParseTreeVisitor\<T>) -> T {
	if ( visitor instanceof <parser.grammarName>Visitor ) return ((<parser.grammarName>Visitor\<? extends T>)visitor).visit<struct.derivedFromName; format="cap">(this);
	else return visitor.visitChildren(this);
}
>>

AttributeDecl(d) ::= "let <d.name>: <d.type><if(d.initValue)> = <d.initValue><endif>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if(!x.isLocal)>(_localctx as <x.ctx.name>).<endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "(_localctx.<actionChunk.ctx.name>)"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec)  ::= "precpred(_ctx, <opPrec>)"
recRuleSetReturnAction(src,name)	  ::= "$<name>=$<src>.<name>;"
recRuleSetStopToken()                 ::= "_ctx.stop = input.lt(-1);"

recRuleAltStartAction(ruleName, ctxName, label, isListLabel) ::= <<
_localctx = <ctxName>Context::new(_parentctx, _parentState);
<if(label)>
<if(isListLabel)>
_localctx.<label>.add(_prevctx);
<else>
_localctx.<label> = _prevctx;
<endif>
<endif>
<if(label)>_localctx.<label> = _prevctx;<endif>
pushNewRecursionContext(_localctx, _startState, RULE_<ruleName>);
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= <<
_localctx = <currentAltLabel; format="cap">Context::new( <ruleName; format="cap">Context::new(_parentctx, _parentState));
<if(label)>
<if(isListLabel)>
((<currentAltLabel; format="cap">Context)_localctx).<label>.add(_prevctx);
<else>
((<currentAltLabel; format="cap">Context)_localctx).<label> = _prevctx;
<endif>
<endif>
pushNewRecursionContext(_localctx, _startState, RULE_<ruleName>);
>>

recRuleReplaceContext(ctxName) ::= <<
_localctx = <ctxName>Context::new(_localctx);
_ctx = _localctx;
_prevctx = _localctx;
>>

recRuleSetPrevCtx() ::= <<
triggerExitRuleEvent();
_prevctx = _localctx;
>>


LexerFile(lexerFile, lexer, namedActions) ::= <<
<fileHeader(lexerFile.grammarFileName, lexerFile.ANTLRVersion)>
<if(lexerFile.genPackage)>
mod <lexerFile.genPackage>{
<endif>
<namedActions.header>
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
use antlr_rust::atn::ATN;
use antlr_rust::char_stream::CharStream;
use antlr_rust::lexer::{BaseLexer, Lexer};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::lexer_atn_simulator::{LexerATNSimulator, ILexerATNSimulator};
use antlr_rust::prediction_context::PredictionContextCache;
use antlr_rust::recognizer::Recognizer;
use antlr_rust::error_listener::ErrorListener;
use antlr_rust::token_source::TokenSource;
use antlr_rust::common_token_factory::TokenFactory;
use antlr_rust::token::*;
use antlr_rust::rule_context::BaseRuleContext;
use antlr_rust::parser_rule_context::ParserRuleContext;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};

use std::sync::Arc;
use std::cell::RefCell;
use std::rc::Rc;
use std::ops::{Deref, DerefMut};

<lexer>
<if(lexerFile.genPackage)>
}
<endif>
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<

	<if(lexer.tokens)>
		<lexer.tokens:{k | pub const <k>:isize=<lexer.tokens.(k)>}; separator="; \n", wrap, anchor>;
	<endif>
	<if(lexer.channels)>
		<lexer.channels:{c | pub const <c>: usize=<lexer.channels.(c)>}; separator="; \n ", wrap, anchor>;
	<endif>
	<if(rest(lexer.modes))>
		<rest(lexer.modes):{m | pub const <m>: usize=<i>}; separator="; \n", wrap, anchor>;
	<endif>
	pub const channelNames: [&'static str;<length(lexer.channels)>+2] = [
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"<if (lexer.channels)>, <lexer.channels:{c| "<c>"}; separator=", ", wrap, anchor><endif>
	];

	pub const modeNames: [&'static str;<length(lexer.modes)>] = [
		<lexer.modes:{m| "<m>"}; separator=", ", wrap, anchor>
	];

	pub const ruleNames: [&'static str;<length(lexer.ruleNames)>] = [
		<lexer.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
	];

	<vocabulary(lexer.literalNames, lexer.symbolicNames)>

impl\<'a> Deref for <lexer.name>{
	type Target = BaseLexer\<'static>;

	fn deref(&self) -> &Self::Target {
		&self.base
	}
}

impl DerefMut for <lexer.name>{
	fn deref_mut(&mut self) -> &mut Self::Target {
		&mut self.base
	}
}



pub struct <lexer.name> {
	base: <superClass; null="BaseLexer">\<'static>,
//	static { RuntimeMetaData.checkVersion("<lexerFile.ANTLRVersion>", RuntimeMetaData.VERSION); }

}

impl <lexer.name> {
    fn get_rule_names(&self) -> &'static [&'static str] {
        &ruleNames
    }
    fn get_literal_names(&self) -> &[Option\<&str>] {
        &_LITERAL_NAMES
    }

    fn get_symbolic_names(&self) -> &[Option\<&str>] {
        &_SYMBOLIC_NAMES
    }

    fn add_error_listener(&mut self, _listener: Box\<ErrorListener>) {
        self.base.add_error_listener(_listener);
    }

    fn remove_error_listeners(&mut self) {
        self.base.remove_error_listeners()
    }

    fn get_grammar_file_name(&self) -> &'static str {
        "<lexer.name>.g4"
    }

	pub fn new (input: Box\<dyn CharStream>) -> Self {
    	Self {
			base: BaseLexer::new_base_lexer(
				input,
				LexerATNSimulator::new_lexer_atnsimulator(
					_ATN.clone(),
					_decision_to_DFA.clone(),
					_shared_context_cache.clone(),
                    Box::new(<lexer.name>Actions{<namedActions.init>})
				)
			)
	    }
	}
}

struct <lexer.name>Actions {
	<namedActions.fields>
}

impl <lexer.name>Actions{
	<namedActions.members>
}

impl Recognizer for <lexer.name>Actions{
	<dumpActions(lexer, "", actionFuncs, sempredFuncs)>
}

impl TokenSource for <lexer.name> {
    fn next_token(&mut self) -> Box\<dyn Token> {
        self.base.next_token()
    }

    fn get_line(&self) -> isize {
        self.base.get_line()
    }

    fn get_char_position_in_line(&self) -> isize {
        self.base.get_char_position_in_line()
    }

    fn get_input_stream(&mut self) -> &mut dyn CharStream {
        self.base.get_input_stream()
    }

    fn get_token_factory(&self) -> &dyn TokenFactory {
        self.base.get_token_factory()
    }
}


	<atn>
>>

SerializedATN(model) ::= <<

lazy_static! {
    static ref _ATN: Arc\<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc\<Vec\<DFA\>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ))
        }
        Arc::new(dfa)
    };
}



<if(rest(model.segments))>
<! requires segmented representation !>
private static final int _serializedATNSegments = <length(model.segments)>;
<model.segments:{segment|private static final String _serializedATNSegment<i0> =
	"<segment; wrap={"+<\n><\t>"}>";}; separator="\n">
public static final String _serializedATN = Utils.join(
	new String[] {
		<model.segments:{segment | _serializedATNSegment<i0>}; separator=",\n">
	},
	""
);
<else>
<! only one segment, can be inlined !>
const _serializedATN:&'static str =
	"<model.serialized; wrap={\\<\n><\t>}>";
<endif>
<!	org.antlr.v4.tool.DOTGenerator dot = new org.antlr.v4.tool.DOTGenerator(null);!>
<!	System.out.println(dot.getDOT(_ATN.decisionToState.get(0), ruleNames, false));!>
<!	System.out.println(dot.getDOT(_ATN.ruleToStartState[2], ruleNames, false));!>
>>

/** Using a type to init value map, try to init a type; if not in table
 *	must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".rs"
